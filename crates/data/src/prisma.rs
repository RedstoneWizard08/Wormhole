// File generated by Prisma Client Rust. DO NOT EDIT

pub static DATAMODEL_STR: &'static str = include_str!("/mnt/vol/Wormhole/prisma/schema.prisma");
static DATABASE_STR: &'static str = "sqlite";
pub use _prisma::*;
use prisma_client_rust::scalar_types::*;
pub mod _prisma {
    use super::*;
    pub struct PrismaClientBuilder {
        url: Option<String>,
        action_notifier: ::prisma_client_rust::ActionNotifier,
    }
    impl PrismaClientBuilder {
        fn new() -> Self {
            Self {
                url: None,
                action_notifier: ::prisma_client_rust::ActionNotifier::new(),
            }
        }
        pub fn with_url(mut self, url: String) -> Self {
            self.url = Some(url);
            self
        }
        pub async fn build(self) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
            let internals = ::prisma_client_rust::PrismaClientInternals::new(
                self.url,
                self.action_notifier,
                super::DATAMODEL_STR,
            )
            .await?;
            Ok(PrismaClient(internals))
        }
    }
    pub struct PrismaClient(::prisma_client_rust::PrismaClientInternals);
    impl ::std::fmt::Debug for PrismaClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.debug_struct("PrismaClient").finish()
        }
    }
    impl PrismaClient {
        pub fn _builder() -> PrismaClientBuilder {
            PrismaClientBuilder::new()
        }
        pub fn _query_raw<T: ::prisma_client_rust::Data>(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::QueryRaw<T> {
            ::prisma_client_rust::QueryRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub fn _execute_raw(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::ExecuteRaw {
            ::prisma_client_rust::ExecuteRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub async fn _batch<
            'batch,
            T: ::prisma_client_rust::BatchContainer<'batch, Marker>,
            Marker,
        >(
            &self,
            queries: T,
        ) -> ::prisma_client_rust::Result<
            <T as ::prisma_client_rust::BatchContainer<'batch, Marker>>::ReturnType,
        > {
            ::prisma_client_rust::batch(queries, &self.0).await
        }
        pub fn _transaction(&self) -> ::prisma_client_rust::TransactionBuilder<Self> {
            ::prisma_client_rust::TransactionBuilder::_new(self, &self.0)
        }
        pub fn instance(&self) -> super::instance::Actions {
            super::instance::Actions { client: &self.0 }
        }
        pub fn installed_mod(&self) -> super::installed_mod::Actions {
            super::installed_mod::Actions { client: &self.0 }
        }
    }
    impl ::prisma_client_rust::PrismaClient for PrismaClient {
        fn internals(&self) -> &::prisma_client_rust::PrismaClientInternals {
            &self.0
        }
        fn internals_mut(&mut self) -> &mut ::prisma_client_rust::PrismaClientInternals {
            &mut self.0
        }
        fn with_tx_id(&self, tx_id: Option<::prisma_client_rust::query_core::TxId>) -> Self {
            Self(self.0.with_tx_id(tx_id))
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum TransactionIsolationLevel {
        #[serde(rename = "Serializable")]
        Serializable,
    }
    impl ToString for TransactionIsolationLevel {
        fn to_string(&self) -> String {
            match self {
                Self::Serializable => "Serializable".to_string(),
            }
        }
    }
    impl ::prisma_client_rust::TransactionIsolationLevel for TransactionIsolationLevel {}
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum InstanceScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "plugin")]
        Plugin,
        #[serde(rename = "description")]
        Description,
        #[serde(rename = "updated")]
        Updated,
        #[serde(rename = "iconUrl")]
        IconUrl,
        #[serde(rename = "bannerUrl")]
        BannerUrl,
        #[serde(rename = "extraData")]
        ExtraData,
    }
    impl ToString for InstanceScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Name => "name".to_string(),
                Self::Plugin => "plugin".to_string(),
                Self::Description => "description".to_string(),
                Self::Updated => "updated".to_string(),
                Self::IconUrl => "iconUrl".to_string(),
                Self::BannerUrl => "bannerUrl".to_string(),
                Self::ExtraData => "extraData".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum InstalledModScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "fileSize")]
        FileSize,
        #[serde(rename = "updated")]
        Updated,
        #[serde(rename = "iconUrl")]
        IconUrl,
        #[serde(rename = "instanceId")]
        InstanceId,
        #[serde(rename = "source")]
        Source,
        #[serde(rename = "projectId")]
        ProjectId,
        #[serde(rename = "projectName")]
        ProjectName,
        #[serde(rename = "projectDesc")]
        ProjectDesc,
        #[serde(rename = "projectVersion")]
        ProjectVersion,
    }
    impl ToString for InstalledModScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::FileSize => "fileSize".to_string(),
                Self::Updated => "updated".to_string(),
                Self::IconUrl => "iconUrl".to_string(),
                Self::InstanceId => "instanceId".to_string(),
                Self::Source => "source".to_string(),
                Self::ProjectId => "projectId".to_string(),
                Self::ProjectName => "projectName".to_string(),
                Self::ProjectDesc => "projectDesc".to_string(),
                Self::ProjectVersion => "projectVersion".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum SortOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }
    impl ToString for SortOrder {
        fn to_string(&self) -> String {
            match self {
                Self::Asc => "asc".to_string(),
                Self::Desc => "desc".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum NullsOrder {
        #[serde(rename = "first")]
        First,
        #[serde(rename = "last")]
        Last,
    }
    impl ToString for NullsOrder {
        fn to_string(&self) -> String {
            match self {
                Self::First => "first".to_string(),
                Self::Last => "last".to_string(),
            }
        }
    }
    impl Into<::prisma_client_rust::PrismaValue> for SortOrder {
        fn into(self) -> ::prisma_client_rust::PrismaValue {
            match self {
                SortOrder::Asc => ::prisma_client_rust::PrismaValue::String("asc".to_string()),
                SortOrder::Desc => ::prisma_client_rust::PrismaValue::String("desc".to_string()),
            }
        }
    }
    pub mod read_filters {
        use super::*;
        #[derive(Debug, Clone)]
        pub enum StringFilter {
            Equals(String),
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Not(String),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Contains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::EndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "endsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum StringNullableFilter {
            Equals(Option<String>),
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Not(Option<String>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringNullableFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            value
                                .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Contains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::EndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "endsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                    )]),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum DateTimeFilter {
            Equals(DateTime),
            InVec(Vec<DateTime>),
            NotInVec(Vec<DateTime>),
            Lt(DateTime),
            Lte(DateTime),
            Gt(DateTime),
            Gte(DateTime),
            Not(DateTime),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for DateTimeFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::DateTime(value),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum IntFilter {
            Equals(Int),
            InVec(Vec<Int>),
            NotInVec(Vec<Int>),
            Lt(Int),
            Lte(Int),
            Gt(Int),
            Gte(Int),
            Not(Int),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for IntFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Int(value),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::Int(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::Int(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value),
                    )]),
                }
            }
        }
    }
    pub mod write_params {
        use super::*;
        #[derive(Debug, Clone)]
        pub enum DateTimeParam {
            Set(DateTime),
        }
        impl Into<::prisma_client_rust::PrismaValue> for DateTimeParam {
            fn into(self) -> ::prisma_client_rust::PrismaValue {
                match self {
                    Self::Set(value) => ::prisma_client_rust::PrismaValue::DateTime(value),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum IntParam {
            Set(Int),
            Increment(Int),
            Decrement(Int),
            Multiply(Int),
            Divide(Int),
        }
        impl Into<::prisma_client_rust::PrismaValue> for IntParam {
            fn into(self) -> ::prisma_client_rust::PrismaValue {
                match self {
                    Self::Set(value) => ::prisma_client_rust::PrismaValue::Int(value),
                    Self::Increment(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value),
                    )]),
                    Self::Decrement(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value),
                    )]),
                    Self::Multiply(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value),
                    )]),
                    Self::Divide(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value),
                    )]),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum StringParam {
            Set(String),
        }
        impl Into<::prisma_client_rust::PrismaValue> for StringParam {
            fn into(self) -> ::prisma_client_rust::PrismaValue {
                match self {
                    Self::Set(value) => ::prisma_client_rust::PrismaValue::String(value),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum StringNullableParam {
            Set(Option<String>),
        }
        impl Into<::prisma_client_rust::PrismaValue> for StringNullableParam {
            fn into(self) -> ::prisma_client_rust::PrismaValue {
                match self {
                    Self::Set(value) => value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                }
            }
        }
    }
}
pub mod instance {
    use super::{_prisma::*, *};
    pub const NAME: &str = "Instance";
    #[derive(Debug, Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(super::_prisma::read_filters::IntFilter),
        Name(super::_prisma::read_filters::StringFilter),
        Plugin(super::_prisma::read_filters::StringFilter),
        Description(super::_prisma::read_filters::StringFilter),
        Updated(super::_prisma::read_filters::DateTimeFilter),
        IconUrl(super::_prisma::read_filters::StringNullableFilter),
        BannerUrl(super::_prisma::read_filters::StringNullableFilter),
        ExtraData(super::_prisma::read_filters::StringFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::Plugin(value) => (plugin::NAME, value.into()),
                Self::Description(value) => (description::NAME, value.into()),
                Self::Updated(value) => (updated::NAME, value.into()),
                Self::IconUrl(value) => (icon_url::NAME, value.into()),
                Self::BannerUrl(value) => (banner_url::NAME, value.into()),
                Self::ExtraData(value) => (extra_data::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    #[derive(Debug, Clone)]
    pub enum UniqueWhereParam {
        IdEquals(Int),
    }
    impl ::prisma_client_rust::WhereInput for UniqueWhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                UniqueWhereParam::IdEquals(value) => (
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Int(value),
                    ),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum OrderByWithRelationParam {
        Id(super::SortOrder),
        Name(super::SortOrder),
        Plugin(super::SortOrder),
        Description(super::SortOrder),
        Updated(super::SortOrder),
        IconUrl(super::SortOrder),
        BannerUrl(super::SortOrder),
        ExtraData(super::SortOrder),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(param) => ("id", param.into()),
                Self::Name(param) => ("name", param.into()),
                Self::Plugin(param) => ("plugin", param.into()),
                Self::Description(param) => ("description", param.into()),
                Self::Updated(param) => ("updated", param.into()),
                Self::IconUrl(param) => ("iconUrl", param.into()),
                Self::BannerUrl(param) => ("bannerUrl", param.into()),
                Self::ExtraData(param) => ("extraData", param.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Debug, Clone)]
    pub enum SetParam {
        Id(super::_prisma::write_params::IntParam),
        Name(super::_prisma::write_params::StringParam),
        Plugin(super::_prisma::write_params::StringParam),
        Description(super::_prisma::write_params::StringParam),
        Updated(super::_prisma::write_params::DateTimeParam),
        IconUrl(super::_prisma::write_params::StringNullableParam),
        BannerUrl(super::_prisma::write_params::StringNullableParam),
        ExtraData(super::_prisma::write_params::StringParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(value) => (id::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::Plugin(value) => (plugin::NAME, value.into()),
                Self::Description(value) => (description::NAME, value.into()),
                Self::Updated(value) => (updated::NAME, value.into()),
                Self::IconUrl(value) => (icon_url::NAME, value.into()),
                Self::BannerUrl(value) => (banner_url::NAME, value.into()),
                Self::ExtraData(value) => (extra_data::NAME, value.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum UncheckedSetParam {
        Id(super::_prisma::write_params::IntParam),
        Name(super::_prisma::write_params::StringParam),
        Plugin(super::_prisma::write_params::StringParam),
        Description(super::_prisma::write_params::StringParam),
        Updated(super::_prisma::write_params::DateTimeParam),
        IconUrl(super::_prisma::write_params::StringNullableParam),
        BannerUrl(super::_prisma::write_params::StringNullableParam),
        ExtraData(super::_prisma::write_params::StringParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(value) => ("id", value.into()),
                Self::Name(value) => ("name", value.into()),
                Self::Plugin(value) => ("plugin", value.into()),
                Self::Description(value) => ("description", value.into()),
                Self::Updated(value) => ("updated", value.into()),
                Self::IconUrl(value) => ("iconUrl", value.into()),
                Self::BannerUrl(value) => ("bannerUrl", value.into()),
                Self::ExtraData(value) => ("extraData", value.into()),
            };
            (k.to_string(), v)
        }
    }
    ::prisma_client_rust::macros::select_factory!(
        _select_instance,
        select,
        prisma::instance,
        struct Data {
            #[serde(rename = "id")]
            id: id::Type,
            #[serde(rename = "name")]
            name: name::Type,
            #[serde(rename = "plugin")]
            plugin: plugin::Type,
            #[serde(rename = "description")]
            description: description::Type,
            #[serde(rename = "updated")]
            updated: updated::Type,
            #[serde(rename = "iconUrl")]
            icon_url: icon_url::Type,
            #[serde(rename = "bannerUrl")]
            banner_url: banner_url::Type,
            #[serde(rename = "extraData")]
            extra_data: extra_data::Type,
        },
        [
            (id, Scalar),
            (name, Scalar),
            (plugin, Scalar),
            (description, Scalar),
            (updated, Scalar),
            (icon_url, Scalar),
            (banner_url, Scalar),
            (extra_data, Scalar)
        ]
    );
    pub enum SelectParam {
        Id(id::Select),
        Name(name::Select),
        Plugin(plugin::Select),
        Description(description::Select),
        Updated(updated::Select),
        IconUrl(icon_url::Select),
        BannerUrl(banner_url::Select),
        ExtraData(extra_data::Select),
    }
    impl Into<::prisma_client_rust::Selection> for SelectParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.into(),
                Self::Name(data) => data.into(),
                Self::Plugin(data) => data.into(),
                Self::Description(data) => data.into(),
                Self::Updated(data) => data.into(),
                Self::IconUrl(data) => data.into(),
                Self::BannerUrl(data) => data.into(),
                Self::ExtraData(data) => data.into(),
            }
        }
    }
    ::prisma_client_rust::macros::include_factory!(
        _include_instance,
        include,
        prisma::instance,
        struct Data {
            #[serde(rename = "id")]
            id: id::Type,
            #[serde(rename = "name")]
            name: name::Type,
            #[serde(rename = "plugin")]
            plugin: plugin::Type,
            #[serde(rename = "description")]
            description: description::Type,
            #[serde(rename = "updated")]
            updated: updated::Type,
            #[serde(rename = "iconUrl")]
            icon_url: icon_url::Type,
            #[serde(rename = "bannerUrl")]
            banner_url: banner_url::Type,
            #[serde(rename = "extraData")]
            extra_data: extra_data::Type,
        },
        []
    );
    pub enum IncludeParam {
        Id(id::Include),
        Name(name::Include),
        Plugin(plugin::Include),
        Description(description::Include),
        Updated(updated::Include),
        IconUrl(icon_url::Include),
        BannerUrl(banner_url::Include),
        ExtraData(extra_data::Include),
    }
    impl Into<::prisma_client_rust::Selection> for IncludeParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.into(),
                Self::Name(data) => data.into(),
                Self::Plugin(data) => data.into(),
                Self::Description(data) => data.into(),
                Self::Updated(data) => data.into(),
                Self::IconUrl(data) => data.into(),
                Self::BannerUrl(data) => data.into(),
                Self::ExtraData(data) => data.into(),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub struct Create {
        pub name: String,
        pub plugin: String,
        pub description: String,
        pub extra_data: String,
        pub _params: Vec<SetParam>,
    }
    impl Create {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
            client.instance().create(
                self.name,
                self.plugin,
                self.description,
                self.extra_data,
                self._params,
            )
        }
        pub fn to_params(mut self) -> Vec<SetParam> {
            self._params.extend([
                name::set(self.name),
                plugin::set(self.plugin),
                description::set(self.description),
                extra_data::set(self.extra_data),
            ]);
            self._params
        }
    }
    pub fn create(
        name: String,
        plugin: String,
        description: String,
        extra_data: String,
        _params: Vec<SetParam>,
    ) -> Create {
        Create {
            name,
            plugin,
            description,
            extra_data,
            _params,
        }
    }
    #[derive(
        Debug,
        Clone,
        :: serde :: Serialize,
        :: serde :: Deserialize,
        :: prisma_client_rust :: specta :: Type,
    )]
    # [specta (rename = "InstanceCreation" , crate = prisma_client_rust :: specta)]
    pub struct CreateUnchecked {
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "plugin")]
        pub plugin: String,
        #[serde(rename = "description")]
        pub description: String,
        #[serde(rename = "extraData")]
        pub extra_data: String,
        #[serde(skip)]
        pub _params: Vec<UncheckedSetParam>,
    }
    impl CreateUnchecked {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
            client.instance().create_unchecked(
                self.name,
                self.plugin,
                self.description,
                self.extra_data,
                self._params,
            )
        }
        pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
            self._params.extend([
                name::set(self.name),
                plugin::set(self.plugin),
                description::set(self.description),
                extra_data::set(self.extra_data),
            ]);
            self._params
        }
    }
    pub fn create_unchecked(
        name: String,
        plugin: String,
        description: String,
        extra_data: String,
        _params: Vec<UncheckedSetParam>,
    ) -> CreateUnchecked {
        CreateUnchecked {
            name,
            plugin,
            description,
            extra_data,
            _params,
        }
    }
    #[derive(
        Debug,
        Clone,
        :: serde :: Serialize,
        :: serde :: Deserialize,
        :: prisma_client_rust :: specta :: Type,
    )]
    # [specta (rename = "InstanceUpdate" , crate = prisma_client_rust :: specta)]
    pub struct Update {
        #[serde(rename = "id")]
        pub id: id::Type,
        #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
        pub name: Option<name::Type>,
        #[serde(rename = "plugin", skip_serializing_if = "Option::is_none")]
        pub plugin: Option<plugin::Type>,
        #[serde(rename = "description", skip_serializing_if = "Option::is_none")]
        pub description: Option<description::Type>,
        #[serde(rename = "updated", skip_serializing_if = "Option::is_none")]
        pub updated: Option<updated::Type>,
        #[serde(rename = "iconUrl", skip_serializing_if = "Option::is_none")]
        pub icon_url: icon_url::Type,
        #[serde(rename = "bannerUrl", skip_serializing_if = "Option::is_none")]
        pub banner_url: banner_url::Type,
        #[serde(rename = "extraData", skip_serializing_if = "Option::is_none")]
        pub extra_data: Option<extra_data::Type>,
    }
    impl Update {
        pub fn as_params(self) -> Vec<SetParam> {
            let mut params = Vec::new();
            if let Some(field) = self.name {
                params.push(name::set(field));
            }
            if let Some(field) = self.plugin {
                params.push(plugin::set(field));
            }
            if let Some(field) = self.description {
                params.push(description::set(field));
            }
            if let Some(field) = self.updated {
                params.push(updated::set(field));
            }
            if let Some(field) = self.icon_url {
                params.push(icon_url::set(Some(field)));
            }
            if let Some(field) = self.banner_url {
                params.push(banner_url::set(Some(field)));
            }
            if let Some(field) = self.extra_data {
                params.push(extra_data::set(field));
            }
            params
        }
    }
    #[derive(Debug, Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type WhereUnique = UniqueWhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByWithRelationParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(name::NAME),
                ::prisma_client_rust::sel(plugin::NAME),
                ::prisma_client_rust::sel(description::NAME),
                ::prisma_client_rust::sel(updated::NAME),
                ::prisma_client_rust::sel(icon_url::NAME),
                ::prisma_client_rust::sel(banner_url::NAME),
                ::prisma_client_rust::sel(extra_data::NAME),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        :: serde :: Serialize,
        :: serde :: Deserialize,
        :: prisma_client_rust :: specta :: Type,
    )]
    # [specta (rename = "Instance" , crate = prisma_client_rust :: specta)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: id::Type,
        #[serde(rename = "name")]
        pub name: name::Type,
        #[serde(rename = "plugin")]
        pub plugin: plugin::Type,
        #[serde(rename = "description")]
        pub description: description::Type,
        #[serde(rename = "updated")]
        pub updated: updated::Type,
        #[serde(rename = "iconUrl")]
        pub icon_url: icon_url::Type,
        #[serde(rename = "bannerUrl")]
        pub banner_url: banner_url::Type,
        #[serde(rename = "extraData")]
        pub extra_data: extra_data::Type,
    }
    impl Data {}
    ::prisma_client_rust::macros::partial_unchecked_factory!(
        _partial_unchecked_instance,
        prisma::instance,
        struct Data {
            #[serde(rename = "id")]
            pub id: prisma::instance::id::Type,
            #[serde(rename = "name")]
            pub name: prisma::instance::name::Type,
            #[serde(rename = "plugin")]
            pub plugin: prisma::instance::plugin::Type,
            #[serde(rename = "description")]
            pub description: prisma::instance::description::Type,
            #[serde(rename = "updated")]
            pub updated: prisma::instance::updated::Type,
            #[serde(rename = "iconUrl")]
            #[serde(default, with = "::prisma_client_rust::serde::double_option")]
            pub icon_url: prisma::instance::icon_url::Type,
            #[serde(rename = "bannerUrl")]
            #[serde(default, with = "::prisma_client_rust::serde::double_option")]
            pub banner_url: prisma::instance::banner_url::Type,
            #[serde(rename = "extraData")]
            pub extra_data: prisma::instance::extra_data::Type,
        }
    );
    ::prisma_client_rust::macros::filter_factory!(
        _instance_filter,
        prisma::instance,
        [
            (id, Scalar),
            (name, Scalar),
            (plugin, Scalar),
            (description, Scalar),
            (updated, Scalar),
            (icon_url, Scalar),
            (banner_url, Scalar),
            (extra_data, Scalar)
        ]
    );
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
    pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
    pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
            FindUniqueQuery::new(self.client, _where)
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
            FindFirstQuery::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
            FindManyQuery::new(self.client, _where)
        }
        pub fn create(
            self,
            name: String,
            plugin: String,
            description: String,
            extra_data: String,
            mut _params: Vec<SetParam>,
        ) -> CreateQuery<'a> {
            _params.extend([
                name::set(name),
                plugin::set(plugin),
                description::set(description),
                extra_data::set(extra_data),
            ]);
            CreateQuery::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            name: String,
            plugin: String,
            description: String,
            extra_data: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> CreateUncheckedQuery<'a> {
            _params.extend([
                name::set(name),
                plugin::set(plugin),
                description::set(description),
                extra_data::set(extra_data),
            ]);
            CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
            let data = data.into_iter().map(CreateUnchecked::to_params).collect();
            CreateManyQuery::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
            UpdateQuery::new(self.client, _where, _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> UpdateUncheckedQuery<'a> {
            UpdateUncheckedQuery::new(
                self.client,
                _where,
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateManyQuery<'a> {
            UpdateManyQuery::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            _create: Create,
            _update: Vec<SetParam>,
        ) -> UpsertQuery<'a> {
            UpsertQuery::new(self.client, _where, _create.to_params(), _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
            DeleteQuery::new(self.client, _where, vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
            DeleteManyQuery::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
            CountQuery::new(self.client, _where)
        }
    }
    pub mod banner_url {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "bannerUrl";
        pub type Type = Option<String>;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub Option<String>);
        pub fn equals<T: From<Equals>>(value: Option<String>) -> T {
            Equals(value).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::BannerUrl(_prisma::read_filters::StringNullableFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            BannerUrl,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::BannerUrl(v)
            }
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::BannerUrl(_prisma::write_params::StringNullableParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::BannerUrl(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::BannerUrl(_prisma::write_params::StringNullableParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::BannerUrl(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::BannerUrl(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::BannerUrl(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod description {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "description";
        pub type Type = String;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub String);
        pub fn equals<T: From<Equals>>(value: String) -> T {
            Equals(value).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Description(_prisma::read_filters::StringFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Description,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Description(v)
            }
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Description(_prisma::write_params::StringParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Description(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Description(_prisma::write_params::StringParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Description(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Description(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Description(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod extra_data {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "extraData";
        pub type Type = String;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub String);
        pub fn equals<T: From<Equals>>(value: String) -> T {
            Equals(value).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::ExtraData(_prisma::read_filters::StringFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            ExtraData,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::ExtraData(v)
            }
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::ExtraData(_prisma::write_params::StringParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::ExtraData(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ExtraData(_prisma::write_params::StringParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::ExtraData(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ExtraData(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ExtraData(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod icon_url {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "iconUrl";
        pub type Type = Option<String>;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub Option<String>);
        pub fn equals<T: From<Equals>>(value: Option<String>) -> T {
            Equals(value).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::IconUrl(_prisma::read_filters::StringNullableFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            IconUrl,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::IconUrl(v)
            }
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::IconUrl(_prisma::write_params::StringNullableParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::IconUrl(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::IconUrl(_prisma::write_params::StringNullableParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::IconUrl(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::IconUrl(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::IconUrl(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "id";
        pub type Type = Int;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub Int);
        pub fn equals<T: From<Equals>>(value: Int) -> T {
            Equals(value).into()
        }
        impl From<Equals> for UniqueWhereParam {
            fn from(Equals(v): Equals) -> Self {
                UniqueWhereParam::IdEquals(v)
            }
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Id(_prisma::read_filters::IntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<Int>) -> InVec;
            fn not_in_vec(_: Vec<Int>) -> NotInVec;
            fn lt(_: Int) -> Lt;
            fn lte(_: Int) -> Lte;
            fn gt(_: Int) -> Gt;
            fn gte(_: Int) -> Gte;
            fn not(_: Int) -> Not;
        });
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Id(v)
            }
        }
        pub struct Set(pub Int);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(_prisma::write_params::IntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: Int) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::IntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Id(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: Int) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: Int) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: Int) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: Int) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(_prisma::write_params::IntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Id(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod name {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "name";
        pub type Type = String;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub String);
        pub fn equals<T: From<Equals>>(value: String) -> T {
            Equals(value).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Name(_prisma::read_filters::StringFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn not(_: String) -> Not;
        });
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Name(v)
            }
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(_prisma::write_params::StringParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Name(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(_prisma::write_params::StringParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Name(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod plugin {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "plugin";
        pub type Type = String;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub String);
        pub fn equals<T: From<Equals>>(value: String) -> T {
            Equals(value).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Plugin(_prisma::read_filters::StringFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Plugin,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Plugin(v)
            }
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Plugin(_prisma::write_params::StringParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Plugin(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Plugin(_prisma::write_params::StringParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Plugin(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Plugin(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Plugin(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod updated {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "updated";
        pub type Type = DateTime;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub DateTime);
        pub fn equals<T: From<Equals>>(value: DateTime) -> T {
            Equals(value).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Updated(_prisma::read_filters::DateTimeFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            Updated,
            {
                fn in_vec(_: Vec<DateTime>) -> InVec;
                fn not_in_vec(_: Vec<DateTime>) -> NotInVec;
                fn lt(_: DateTime) -> Lt;
                fn lte(_: DateTime) -> Lte;
                fn gt(_: DateTime) -> Gt;
                fn gte(_: DateTime) -> Gte;
                fn not(_: DateTime) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Updated(v)
            }
        }
        pub struct Set(pub DateTime);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Updated(_prisma::write_params::DateTimeParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: DateTime) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Updated(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Updated(_prisma::write_params::DateTimeParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Updated(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Updated(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Updated(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
}
pub mod installed_mod {
    use super::{_prisma::*, *};
    pub const NAME: &str = "InstalledMod";
    #[derive(Debug, Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(super::_prisma::read_filters::IntFilter),
        FileSize(super::_prisma::read_filters::IntFilter),
        Updated(super::_prisma::read_filters::DateTimeFilter),
        IconUrl(super::_prisma::read_filters::StringNullableFilter),
        InstanceId(super::_prisma::read_filters::IntFilter),
        Source(super::_prisma::read_filters::StringFilter),
        ProjectId(super::_prisma::read_filters::StringFilter),
        ProjectName(super::_prisma::read_filters::StringFilter),
        ProjectDesc(super::_prisma::read_filters::StringNullableFilter),
        ProjectVersion(super::_prisma::read_filters::StringNullableFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::FileSize(value) => (file_size::NAME, value.into()),
                Self::Updated(value) => (updated::NAME, value.into()),
                Self::IconUrl(value) => (icon_url::NAME, value.into()),
                Self::InstanceId(value) => (instance_id::NAME, value.into()),
                Self::Source(value) => (source::NAME, value.into()),
                Self::ProjectId(value) => (project_id::NAME, value.into()),
                Self::ProjectName(value) => (project_name::NAME, value.into()),
                Self::ProjectDesc(value) => (project_desc::NAME, value.into()),
                Self::ProjectVersion(value) => (project_version::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    #[derive(Debug, Clone)]
    pub enum UniqueWhereParam {
        IdEquals(Int),
        ProjectIdEquals(String),
    }
    impl ::prisma_client_rust::WhereInput for UniqueWhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                UniqueWhereParam::IdEquals(value) => (
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Int(value),
                    ),
                ),
                UniqueWhereParam::ProjectIdEquals(value) => (
                    "projectId",
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::String(value),
                    ),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum OrderByWithRelationParam {
        Id(super::SortOrder),
        FileSize(super::SortOrder),
        Updated(super::SortOrder),
        IconUrl(super::SortOrder),
        InstanceId(super::SortOrder),
        Source(super::SortOrder),
        ProjectId(super::SortOrder),
        ProjectName(super::SortOrder),
        ProjectDesc(super::SortOrder),
        ProjectVersion(super::SortOrder),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(param) => ("id", param.into()),
                Self::FileSize(param) => ("fileSize", param.into()),
                Self::Updated(param) => ("updated", param.into()),
                Self::IconUrl(param) => ("iconUrl", param.into()),
                Self::InstanceId(param) => ("instanceId", param.into()),
                Self::Source(param) => ("source", param.into()),
                Self::ProjectId(param) => ("projectId", param.into()),
                Self::ProjectName(param) => ("projectName", param.into()),
                Self::ProjectDesc(param) => ("projectDesc", param.into()),
                Self::ProjectVersion(param) => ("projectVersion", param.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Debug, Clone)]
    pub enum SetParam {
        Id(super::_prisma::write_params::IntParam),
        FileSize(super::_prisma::write_params::IntParam),
        Updated(super::_prisma::write_params::DateTimeParam),
        IconUrl(super::_prisma::write_params::StringNullableParam),
        InstanceId(super::_prisma::write_params::IntParam),
        Source(super::_prisma::write_params::StringParam),
        ProjectId(super::_prisma::write_params::StringParam),
        ProjectName(super::_prisma::write_params::StringParam),
        ProjectDesc(super::_prisma::write_params::StringNullableParam),
        ProjectVersion(super::_prisma::write_params::StringNullableParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(value) => (id::NAME, value.into()),
                Self::FileSize(value) => (file_size::NAME, value.into()),
                Self::Updated(value) => (updated::NAME, value.into()),
                Self::IconUrl(value) => (icon_url::NAME, value.into()),
                Self::InstanceId(value) => (instance_id::NAME, value.into()),
                Self::Source(value) => (source::NAME, value.into()),
                Self::ProjectId(value) => (project_id::NAME, value.into()),
                Self::ProjectName(value) => (project_name::NAME, value.into()),
                Self::ProjectDesc(value) => (project_desc::NAME, value.into()),
                Self::ProjectVersion(value) => (project_version::NAME, value.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum UncheckedSetParam {
        Id(super::_prisma::write_params::IntParam),
        FileSize(super::_prisma::write_params::IntParam),
        Updated(super::_prisma::write_params::DateTimeParam),
        IconUrl(super::_prisma::write_params::StringNullableParam),
        InstanceId(super::_prisma::write_params::IntParam),
        Source(super::_prisma::write_params::StringParam),
        ProjectId(super::_prisma::write_params::StringParam),
        ProjectName(super::_prisma::write_params::StringParam),
        ProjectDesc(super::_prisma::write_params::StringNullableParam),
        ProjectVersion(super::_prisma::write_params::StringNullableParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(value) => ("id", value.into()),
                Self::FileSize(value) => ("fileSize", value.into()),
                Self::Updated(value) => ("updated", value.into()),
                Self::IconUrl(value) => ("iconUrl", value.into()),
                Self::InstanceId(value) => ("instanceId", value.into()),
                Self::Source(value) => ("source", value.into()),
                Self::ProjectId(value) => ("projectId", value.into()),
                Self::ProjectName(value) => ("projectName", value.into()),
                Self::ProjectDesc(value) => ("projectDesc", value.into()),
                Self::ProjectVersion(value) => ("projectVersion", value.into()),
            };
            (k.to_string(), v)
        }
    }
    ::prisma_client_rust::macros::select_factory!(
        _select_installed_mod,
        select,
        prisma::installed_mod,
        struct Data {
            #[serde(rename = "id")]
            id: id::Type,
            #[serde(rename = "fileSize")]
            file_size: file_size::Type,
            #[serde(rename = "updated")]
            updated: updated::Type,
            #[serde(rename = "iconUrl")]
            icon_url: icon_url::Type,
            #[serde(rename = "instanceId")]
            instance_id: instance_id::Type,
            #[serde(rename = "source")]
            source: source::Type,
            #[serde(rename = "projectId")]
            project_id: project_id::Type,
            #[serde(rename = "projectName")]
            project_name: project_name::Type,
            #[serde(rename = "projectDesc")]
            project_desc: project_desc::Type,
            #[serde(rename = "projectVersion")]
            project_version: project_version::Type,
        },
        [
            (id, Scalar),
            (file_size, Scalar),
            (updated, Scalar),
            (icon_url, Scalar),
            (instance_id, Scalar),
            (source, Scalar),
            (project_id, Scalar),
            (project_name, Scalar),
            (project_desc, Scalar),
            (project_version, Scalar)
        ]
    );
    pub enum SelectParam {
        Id(id::Select),
        FileSize(file_size::Select),
        Updated(updated::Select),
        IconUrl(icon_url::Select),
        InstanceId(instance_id::Select),
        Source(source::Select),
        ProjectId(project_id::Select),
        ProjectName(project_name::Select),
        ProjectDesc(project_desc::Select),
        ProjectVersion(project_version::Select),
    }
    impl Into<::prisma_client_rust::Selection> for SelectParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.into(),
                Self::FileSize(data) => data.into(),
                Self::Updated(data) => data.into(),
                Self::IconUrl(data) => data.into(),
                Self::InstanceId(data) => data.into(),
                Self::Source(data) => data.into(),
                Self::ProjectId(data) => data.into(),
                Self::ProjectName(data) => data.into(),
                Self::ProjectDesc(data) => data.into(),
                Self::ProjectVersion(data) => data.into(),
            }
        }
    }
    ::prisma_client_rust::macros::include_factory!(
        _include_installed_mod,
        include,
        prisma::installed_mod,
        struct Data {
            #[serde(rename = "id")]
            id: id::Type,
            #[serde(rename = "fileSize")]
            file_size: file_size::Type,
            #[serde(rename = "updated")]
            updated: updated::Type,
            #[serde(rename = "iconUrl")]
            icon_url: icon_url::Type,
            #[serde(rename = "instanceId")]
            instance_id: instance_id::Type,
            #[serde(rename = "source")]
            source: source::Type,
            #[serde(rename = "projectId")]
            project_id: project_id::Type,
            #[serde(rename = "projectName")]
            project_name: project_name::Type,
            #[serde(rename = "projectDesc")]
            project_desc: project_desc::Type,
            #[serde(rename = "projectVersion")]
            project_version: project_version::Type,
        },
        []
    );
    pub enum IncludeParam {
        Id(id::Include),
        FileSize(file_size::Include),
        Updated(updated::Include),
        IconUrl(icon_url::Include),
        InstanceId(instance_id::Include),
        Source(source::Include),
        ProjectId(project_id::Include),
        ProjectName(project_name::Include),
        ProjectDesc(project_desc::Include),
        ProjectVersion(project_version::Include),
    }
    impl Into<::prisma_client_rust::Selection> for IncludeParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.into(),
                Self::FileSize(data) => data.into(),
                Self::Updated(data) => data.into(),
                Self::IconUrl(data) => data.into(),
                Self::InstanceId(data) => data.into(),
                Self::Source(data) => data.into(),
                Self::ProjectId(data) => data.into(),
                Self::ProjectName(data) => data.into(),
                Self::ProjectDesc(data) => data.into(),
                Self::ProjectVersion(data) => data.into(),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub struct Create {
        pub file_size: Int,
        pub instance_id: Int,
        pub source: String,
        pub project_id: String,
        pub project_name: String,
        pub _params: Vec<SetParam>,
    }
    impl Create {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
            client.installed_mod().create(
                self.file_size,
                self.instance_id,
                self.source,
                self.project_id,
                self.project_name,
                self._params,
            )
        }
        pub fn to_params(mut self) -> Vec<SetParam> {
            self._params.extend([
                file_size::set(self.file_size),
                instance_id::set(self.instance_id),
                source::set(self.source),
                project_id::set(self.project_id),
                project_name::set(self.project_name),
            ]);
            self._params
        }
    }
    pub fn create(
        file_size: Int,
        instance_id: Int,
        source: String,
        project_id: String,
        project_name: String,
        _params: Vec<SetParam>,
    ) -> Create {
        Create {
            file_size,
            instance_id,
            source,
            project_id,
            project_name,
            _params,
        }
    }
    #[derive(
        Debug,
        Clone,
        :: serde :: Serialize,
        :: serde :: Deserialize,
        :: prisma_client_rust :: specta :: Type,
    )]
    # [specta (rename = "InstalledModCreation" , crate = prisma_client_rust :: specta)]
    pub struct CreateUnchecked {
        #[serde(rename = "fileSize")]
        pub file_size: Int,
        #[serde(rename = "instanceId")]
        pub instance_id: Int,
        #[serde(rename = "source")]
        pub source: String,
        #[serde(rename = "projectId")]
        pub project_id: String,
        #[serde(rename = "projectName")]
        pub project_name: String,
        #[serde(skip)]
        pub _params: Vec<UncheckedSetParam>,
    }
    impl CreateUnchecked {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
            client.installed_mod().create_unchecked(
                self.file_size,
                self.instance_id,
                self.source,
                self.project_id,
                self.project_name,
                self._params,
            )
        }
        pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
            self._params.extend([
                file_size::set(self.file_size),
                instance_id::set(self.instance_id),
                source::set(self.source),
                project_id::set(self.project_id),
                project_name::set(self.project_name),
            ]);
            self._params
        }
    }
    pub fn create_unchecked(
        file_size: Int,
        instance_id: Int,
        source: String,
        project_id: String,
        project_name: String,
        _params: Vec<UncheckedSetParam>,
    ) -> CreateUnchecked {
        CreateUnchecked {
            file_size,
            instance_id,
            source,
            project_id,
            project_name,
            _params,
        }
    }
    #[derive(
        Debug,
        Clone,
        :: serde :: Serialize,
        :: serde :: Deserialize,
        :: prisma_client_rust :: specta :: Type,
    )]
    # [specta (rename = "InstalledModUpdate" , crate = prisma_client_rust :: specta)]
    pub struct Update {
        #[serde(rename = "id")]
        pub id: id::Type,
        #[serde(rename = "fileSize", skip_serializing_if = "Option::is_none")]
        pub file_size: Option<file_size::Type>,
        #[serde(rename = "updated", skip_serializing_if = "Option::is_none")]
        pub updated: Option<updated::Type>,
        #[serde(rename = "iconUrl", skip_serializing_if = "Option::is_none")]
        pub icon_url: icon_url::Type,
        #[serde(rename = "instanceId", skip_serializing_if = "Option::is_none")]
        pub instance_id: Option<instance_id::Type>,
        #[serde(rename = "source", skip_serializing_if = "Option::is_none")]
        pub source: Option<source::Type>,
        #[serde(rename = "projectId", skip_serializing_if = "Option::is_none")]
        pub project_id: Option<project_id::Type>,
        #[serde(rename = "projectName", skip_serializing_if = "Option::is_none")]
        pub project_name: Option<project_name::Type>,
        #[serde(rename = "projectDesc", skip_serializing_if = "Option::is_none")]
        pub project_desc: project_desc::Type,
        #[serde(rename = "projectVersion", skip_serializing_if = "Option::is_none")]
        pub project_version: project_version::Type,
    }
    impl Update {
        pub fn as_params(self) -> Vec<SetParam> {
            let mut params = Vec::new();
            if let Some(field) = self.file_size {
                params.push(file_size::set(field));
            }
            if let Some(field) = self.updated {
                params.push(updated::set(field));
            }
            if let Some(field) = self.icon_url {
                params.push(icon_url::set(Some(field)));
            }
            if let Some(field) = self.instance_id {
                params.push(instance_id::set(field));
            }
            if let Some(field) = self.source {
                params.push(source::set(field));
            }
            if let Some(field) = self.project_id {
                params.push(project_id::set(field));
            }
            if let Some(field) = self.project_name {
                params.push(project_name::set(field));
            }
            if let Some(field) = self.project_desc {
                params.push(project_desc::set(Some(field)));
            }
            if let Some(field) = self.project_version {
                params.push(project_version::set(Some(field)));
            }
            params
        }
    }
    #[derive(Debug, Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type WhereUnique = UniqueWhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByWithRelationParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(file_size::NAME),
                ::prisma_client_rust::sel(updated::NAME),
                ::prisma_client_rust::sel(icon_url::NAME),
                ::prisma_client_rust::sel(instance_id::NAME),
                ::prisma_client_rust::sel(source::NAME),
                ::prisma_client_rust::sel(project_id::NAME),
                ::prisma_client_rust::sel(project_name::NAME),
                ::prisma_client_rust::sel(project_desc::NAME),
                ::prisma_client_rust::sel(project_version::NAME),
            ]
        }
    }
    #[derive(
        Debug,
        Clone,
        :: serde :: Serialize,
        :: serde :: Deserialize,
        :: prisma_client_rust :: specta :: Type,
    )]
    # [specta (rename = "InstalledMod" , crate = prisma_client_rust :: specta)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: id::Type,
        #[serde(rename = "fileSize")]
        pub file_size: file_size::Type,
        #[serde(rename = "updated")]
        pub updated: updated::Type,
        #[serde(rename = "iconUrl")]
        pub icon_url: icon_url::Type,
        #[serde(rename = "instanceId")]
        pub instance_id: instance_id::Type,
        #[serde(rename = "source")]
        pub source: source::Type,
        #[serde(rename = "projectId")]
        pub project_id: project_id::Type,
        #[serde(rename = "projectName")]
        pub project_name: project_name::Type,
        #[serde(rename = "projectDesc")]
        pub project_desc: project_desc::Type,
        #[serde(rename = "projectVersion")]
        pub project_version: project_version::Type,
    }
    impl Data {}
    ::prisma_client_rust::macros::partial_unchecked_factory!(
        _partial_unchecked_installed_mod,
        prisma::installed_mod,
        struct Data {
            #[serde(rename = "id")]
            pub id: prisma::installed_mod::id::Type,
            #[serde(rename = "fileSize")]
            pub file_size: prisma::installed_mod::file_size::Type,
            #[serde(rename = "updated")]
            pub updated: prisma::installed_mod::updated::Type,
            #[serde(rename = "iconUrl")]
            #[serde(default, with = "::prisma_client_rust::serde::double_option")]
            pub icon_url: prisma::installed_mod::icon_url::Type,
            #[serde(rename = "instanceId")]
            pub instance_id: prisma::installed_mod::instance_id::Type,
            #[serde(rename = "source")]
            pub source: prisma::installed_mod::source::Type,
            #[serde(rename = "projectId")]
            pub project_id: prisma::installed_mod::project_id::Type,
            #[serde(rename = "projectName")]
            pub project_name: prisma::installed_mod::project_name::Type,
            #[serde(rename = "projectDesc")]
            #[serde(default, with = "::prisma_client_rust::serde::double_option")]
            pub project_desc: prisma::installed_mod::project_desc::Type,
            #[serde(rename = "projectVersion")]
            #[serde(default, with = "::prisma_client_rust::serde::double_option")]
            pub project_version: prisma::installed_mod::project_version::Type,
        }
    );
    ::prisma_client_rust::macros::filter_factory!(
        _installed_mod_filter,
        prisma::installed_mod,
        [
            (id, Scalar),
            (file_size, Scalar),
            (updated, Scalar),
            (icon_url, Scalar),
            (instance_id, Scalar),
            (source, Scalar),
            (project_id, Scalar),
            (project_name, Scalar),
            (project_desc, Scalar),
            (project_version, Scalar)
        ]
    );
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
    pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
    pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
            FindUniqueQuery::new(self.client, _where)
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
            FindFirstQuery::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
            FindManyQuery::new(self.client, _where)
        }
        pub fn create(
            self,
            file_size: Int,
            instance_id: Int,
            source: String,
            project_id: String,
            project_name: String,
            mut _params: Vec<SetParam>,
        ) -> CreateQuery<'a> {
            _params.extend([
                file_size::set(file_size),
                instance_id::set(instance_id),
                source::set(source),
                project_id::set(project_id),
                project_name::set(project_name),
            ]);
            CreateQuery::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            file_size: Int,
            instance_id: Int,
            source: String,
            project_id: String,
            project_name: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> CreateUncheckedQuery<'a> {
            _params.extend([
                file_size::set(file_size),
                instance_id::set(instance_id),
                source::set(source),
                project_id::set(project_id),
                project_name::set(project_name),
            ]);
            CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
            let data = data.into_iter().map(CreateUnchecked::to_params).collect();
            CreateManyQuery::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
            UpdateQuery::new(self.client, _where, _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> UpdateUncheckedQuery<'a> {
            UpdateUncheckedQuery::new(
                self.client,
                _where,
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateManyQuery<'a> {
            UpdateManyQuery::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            _create: Create,
            _update: Vec<SetParam>,
        ) -> UpsertQuery<'a> {
            UpsertQuery::new(self.client, _where, _create.to_params(), _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
            DeleteQuery::new(self.client, _where, vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
            DeleteManyQuery::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
            CountQuery::new(self.client, _where)
        }
    }
    pub mod file_size {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "fileSize";
        pub type Type = Int;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub Int);
        pub fn equals<T: From<Equals>>(value: Int) -> T {
            Equals(value).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::FileSize(_prisma::read_filters::IntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            FileSize,
            {
                fn in_vec(_: Vec<Int>) -> InVec;
                fn not_in_vec(_: Vec<Int>) -> NotInVec;
                fn lt(_: Int) -> Lt;
                fn lte(_: Int) -> Lte;
                fn gt(_: Int) -> Gt;
                fn gte(_: Int) -> Gte;
                fn not(_: Int) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::FileSize(v)
            }
        }
        pub struct Set(pub Int);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::FileSize(_prisma::write_params::IntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: Int) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::IntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::FileSize(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: Int) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: Int) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: Int) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: Int) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::FileSize(_prisma::write_params::IntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::FileSize(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FileSize(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FileSize(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod icon_url {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "iconUrl";
        pub type Type = Option<String>;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub Option<String>);
        pub fn equals<T: From<Equals>>(value: Option<String>) -> T {
            Equals(value).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::IconUrl(_prisma::read_filters::StringNullableFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            IconUrl,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::IconUrl(v)
            }
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::IconUrl(_prisma::write_params::StringNullableParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::IconUrl(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::IconUrl(_prisma::write_params::StringNullableParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::IconUrl(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::IconUrl(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::IconUrl(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "id";
        pub type Type = Int;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub Int);
        pub fn equals<T: From<Equals>>(value: Int) -> T {
            Equals(value).into()
        }
        impl From<Equals> for UniqueWhereParam {
            fn from(Equals(v): Equals) -> Self {
                UniqueWhereParam::IdEquals(v)
            }
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Id(_prisma::read_filters::IntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<Int>) -> InVec;
            fn not_in_vec(_: Vec<Int>) -> NotInVec;
            fn lt(_: Int) -> Lt;
            fn lte(_: Int) -> Lte;
            fn gt(_: Int) -> Gt;
            fn gte(_: Int) -> Gte;
            fn not(_: Int) -> Not;
        });
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Id(v)
            }
        }
        pub struct Set(pub Int);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(_prisma::write_params::IntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: Int) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::IntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Id(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: Int) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: Int) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: Int) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: Int) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(_prisma::write_params::IntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Id(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod instance_id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "instanceId";
        pub type Type = Int;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub Int);
        pub fn equals<T: From<Equals>>(value: Int) -> T {
            Equals(value).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::InstanceId(_prisma::read_filters::IntFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            InstanceId,
            {
                fn in_vec(_: Vec<Int>) -> InVec;
                fn not_in_vec(_: Vec<Int>) -> NotInVec;
                fn lt(_: Int) -> Lt;
                fn lte(_: Int) -> Lte;
                fn gt(_: Int) -> Gt;
                fn gte(_: Int) -> Gte;
                fn not(_: Int) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::InstanceId(v)
            }
        }
        pub struct Set(pub Int);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::InstanceId(_prisma::write_params::IntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: Int) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::IntParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::InstanceId(v)
            }
        }
        pub fn increment<T: From<UpdateOperation>>(value: Int) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: Int) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: Int) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: Int) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::InstanceId(_prisma::write_params::IntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::InstanceId(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::InstanceId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::InstanceId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod project_desc {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "projectDesc";
        pub type Type = Option<String>;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub Option<String>);
        pub fn equals<T: From<Equals>>(value: Option<String>) -> T {
            Equals(value).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::ProjectDesc(_prisma::read_filters::StringNullableFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            ProjectDesc,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::ProjectDesc(v)
            }
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::ProjectDesc(_prisma::write_params::StringNullableParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::ProjectDesc(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ProjectDesc(_prisma::write_params::StringNullableParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::ProjectDesc(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ProjectDesc(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ProjectDesc(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod project_id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "projectId";
        pub type Type = String;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub String);
        pub fn equals<T: From<Equals>>(value: String) -> T {
            Equals(value).into()
        }
        impl From<Equals> for UniqueWhereParam {
            fn from(Equals(v): Equals) -> Self {
                UniqueWhereParam::ProjectIdEquals(v)
            }
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::ProjectId(_prisma::read_filters::StringFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            ProjectId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::ProjectId(v)
            }
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::ProjectId(_prisma::write_params::StringParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::ProjectId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ProjectId(_prisma::write_params::StringParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::ProjectId(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ProjectId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ProjectId(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod project_name {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "projectName";
        pub type Type = String;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub String);
        pub fn equals<T: From<Equals>>(value: String) -> T {
            Equals(value).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::ProjectName(_prisma::read_filters::StringFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            ProjectName,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::ProjectName(v)
            }
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::ProjectName(_prisma::write_params::StringParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::ProjectName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ProjectName(_prisma::write_params::StringParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::ProjectName(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ProjectName(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ProjectName(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod project_version {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "projectVersion";
        pub type Type = Option<String>;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub Option<String>);
        pub fn equals<T: From<Equals>>(value: Option<String>) -> T {
            Equals(value).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::ProjectVersion(_prisma::read_filters::StringNullableFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            ProjectVersion,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::ProjectVersion(v)
            }
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::ProjectVersion(_prisma::write_params::StringNullableParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::ProjectVersion(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ProjectVersion(_prisma::write_params::StringNullableParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::ProjectVersion(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ProjectVersion(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ProjectVersion(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod source {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "source";
        pub type Type = String;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub String);
        pub fn equals<T: From<Equals>>(value: String) -> T {
            Equals(value).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Source(_prisma::read_filters::StringFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Source,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Source(v)
            }
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Source(_prisma::write_params::StringParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Source(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Source(_prisma::write_params::StringParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Source(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Source(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Source(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod updated {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "updated";
        pub type Type = DateTime;
        pub type RecursiveSafeType = Type;
        pub struct Equals(pub DateTime);
        pub fn equals<T: From<Equals>>(value: DateTime) -> T {
            Equals(value).into()
        }
        impl From<Equals> for WhereParam {
            fn from(Equals(v): Equals) -> Self {
                WhereParam::Updated(_prisma::read_filters::DateTimeFilter::Equals(v))
            }
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            Updated,
            {
                fn in_vec(_: Vec<DateTime>) -> InVec;
                fn not_in_vec(_: Vec<DateTime>) -> NotInVec;
                fn lt(_: DateTime) -> Lt;
                fn lte(_: DateTime) -> Lte;
                fn gt(_: DateTime) -> Gt;
                fn gte(_: DateTime) -> Gte;
                fn not(_: DateTime) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Updated(v)
            }
        }
        pub struct Set(pub DateTime);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Updated(_prisma::write_params::DateTimeParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: DateTime) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Updated(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Updated(_prisma::write_params::DateTimeParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Updated(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Updated(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Select {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Updated(self)
            }
        }
        impl Into<::prisma_client_rust::Selection> for Include {
            fn into(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
}
