// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

export const commands = {
    async getPlugins(pool: unknown | null): Promise<
        __Result__<
            {
                id: string;
                game: number;
                display_name: string;
                icon_url: string;
                banner_url: string;
                fallback_dir: string | null;
                resolvers: SourceMapping[];
            }[],
            boolean
        >
    > {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_plugins", { pool }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getDirs(
        pool: unknown | null
    ): Promise<__Result__<{ root: string; data: string; cache: string; temp: string }, boolean>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_dirs", { pool }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getSourceId(sid: number, pool: unknown | null): Promise<__Result__<string, boolean>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_source_id", { sid, pool }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getInstances(
        gameId: number,
        pool: unknown | null
    ): Promise<
        __Result__<
            {
                id: number | null;
                name: string;
                game_id: number;
                data_dir: string;
                cache_dir: string;
                install_dir: string;
                description: string;
                created: number;
                updated: number;
                loader: string | null;
            }[],
            boolean
        >
    > {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_instances", { gameId, pool }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getInstance(
        instanceId: number,
        pool: unknown | null
    ): Promise<
        __Result__<
            {
                id: number | null;
                name: string;
                game_id: number;
                data_dir: string;
                cache_dir: string;
                install_dir: string;
                description: string;
                created: number;
                updated: number;
                loader: string | null;
            },
            boolean
        >
    > {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_instance", { instanceId, pool }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async addInstance(
        instance: Instance,
        pool: unknown | null
    ): Promise<
        __Result__<
            {
                id: number | null;
                name: string;
                game_id: number;
                data_dir: string;
                cache_dir: string;
                install_dir: string;
                description: string;
                created: number;
                updated: number;
                loader: string | null;
            },
            boolean
        >
    > {
        try {
            return { status: "ok", data: await TAURI_INVOKE("add_instance", { instance, pool }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async deleteInstance(
        instanceId: number,
        pool: unknown | null
    ): Promise<__Result__<null, boolean>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("delete_instance", { instanceId, pool }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async createInstance(
        name: string,
        gameId: number,
        pool: unknown | null
    ): Promise<
        __Result__<
            {
                id: number | null;
                name: string;
                game_id: number;
                data_dir: string;
                cache_dir: string;
                install_dir: string;
                description: string;
                created: number;
                updated: number;
                loader: string | null;
            },
            boolean
        >
    > {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("create_instance", { name, gameId, pool }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async updateInstance(
        instanceId: number,
        desc: string,
        pool: unknown | null
    ): Promise<
        __Result__<
            {
                id: number | null;
                name: string;
                game_id: number;
                data_dir: string;
                cache_dir: string;
                install_dir: string;
                description: string;
                created: number;
                updated: number;
                loader: string | null;
            },
            boolean
        >
    > {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("update_instance", { instanceId, desc, pool }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async info(
        gameId: number,
        pool: unknown | null
    ): Promise<
        __Result__<
            {
                id: string;
                game: number;
                display_name: string;
                icon_url: string;
                banner_url: string;
                fallback_dir: string | null;
                resolvers: SourceMapping[];
            },
            boolean
        >
    > {
        try {
            return { status: "ok", data: await TAURI_INVOKE("info", { gameId, pool }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async searchMods(
        gameId: number,
        resolver: SourceMapping,
        instance: Instance,
        query: string | null,
        opts: { page: number; count: number } | null,
        pool: unknown | null
    ): Promise<
        __Result__<
            { data: Mod[]; page: number | null; per_page: number | null; pages: number | null },
            boolean
        >
    > {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("search_mods", {
                    gameId,
                    resolver,
                    instance,
                    query,
                    opts,
                    pool,
                }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getMod(
        gameId: number,
        resolver: SourceMapping,
        mid: string,
        pool: unknown | null
    ): Promise<
        __Result__<
            {
                id: string;
                game_id: number | null;
                versions: ModVersion[];
                name: string;
                source: number;
                icon: string | null;
                banner: string | null;
                desc: string | null;
                author: string | null;
                downloads: number;
                followers: number;
                url: string | null;
            },
            boolean
        >
    > {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_mod", { gameId, resolver, mid, pool }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getModVersions(
        gameId: number,
        resolver: SourceMapping,
        instance: Instance,
        mid: string,
        pool: unknown | null
    ): Promise<
        __Result__<
            {
                id: string;
                name: string | null;
                file_name: string | null;
                size: string | null;
                hash: string | null;
                url: string | null;
            }[],
            boolean
        >
    > {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_mod_versions", {
                    gameId,
                    resolver,
                    instance,
                    mid,
                    pool,
                }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getModVersion(
        gameId: number,
        resolver: SourceMapping,
        instance: Instance,
        mid: string,
        version: string,
        pool: unknown | null
    ): Promise<
        __Result__<
            {
                id: string;
                name: string | null;
                file_name: string | null;
                size: string | null;
                hash: string | null;
                url: string | null;
            },
            boolean
        >
    > {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_mod_version", {
                    gameId,
                    resolver,
                    instance,
                    mid,
                    version,
                    pool,
                }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getDownloadUrl(
        gameId: number,
        resolver: SourceMapping,
        instance: Instance,
        project: string,
        version: string | null,
        pool: unknown | null
    ): Promise<__Result__<string, boolean>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_download_url", {
                    gameId,
                    resolver,
                    instance,
                    project,
                    version,
                    pool,
                }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async launchGame(
        gameId: number,
        instance: Instance,
        pool: unknown | null
    ): Promise<__Result__<null, boolean>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("launch_game", { gameId, instance, pool }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async sources(gameId: number, pool: unknown | null): Promise<__Result__<string[], boolean>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("sources", { gameId, pool }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getLatestVersion(
        gameId: number,
        resolver: SourceMapping,
        instance: Instance,
        mid: string,
        pool: unknown | null
    ): Promise<
        __Result__<
            {
                id: string;
                name: string | null;
                file_name: string | null;
                size: string | null;
                hash: string | null;
                url: string | null;
            },
            boolean
        >
    > {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_latest_version", {
                    gameId,
                    resolver,
                    instance,
                    mid,
                    pool,
                }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async installMod(
        gameId: number,
        item: Mod,
        version: {
            id: string;
            name: string | null;
            file_name: string | null;
            size: string | null;
            hash: string | null;
            url: string | null;
        } | null,
        instance: Instance,
        pool: unknown | null
    ): Promise<__Result__<null, boolean>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("install_mod", { gameId, item, version, instance, pool }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async uninstallMod(
        gameId: number,
        item: DbMod,
        instance: Instance,
        pool: unknown | null
    ): Promise<__Result__<null, boolean>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("uninstall_mod", { gameId, item, instance, pool }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getMods(
        instanceId: number,
        pool: unknown | null
    ): Promise<
        __Result__<
            {
                id: number | null;
                mod_id: string;
                version_id: string | null;
                name: string;
                file_name: string;
                instance_id: number | null;
                source_id: number | null;
                size: number | null;
                hash: string | null;
                path: string;
            }[],
            boolean
        >
    > {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_mods", { instanceId, pool }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
};

export const events = __makeEvents__<{
    progressCallback: ProgressPayload;
}>({
    progressCallback: "progress_callback",
});

/** user-defined types **/

/**
 * An installed mod.
 */
export type DbMod = {
    /**
     * The mod's ID in the database.
     */
    id: number | null;
    /**
     * The mod's ID in its source.
     */
    mod_id: string;
    /**
     * The ID of the installed version of the mod.
     */
    version_id: string | null;
    /**
     * The mod's name (human-friendly).
     */
    name: string;
    /**
     * The name of the installed file.
     */
    file_name: string;
    /**
     * The instance this mod was installed to.
     */
    instance_id: number | null;
    /**
     * The source that this mod belongs to.
     */
    source_id: number | null;
    /**
     * The size of the installed file.
     */
    size: number | null;
    /**
     * The SHA-512 hash of the installed file.
     */
    hash: string | null;
    /**
     * A JSON-serialized list of paths, relative
     * to the instance's root data directory, that
     * were created when this mod was installed.
     */
    path: string;
};
export type Dirs = { root: string; data: string; cache: string; temp: string };
/**
 * A supported game. This only holds metadata.
 */
export type Game = {
    /**
     * The game's ID in the database.
     */
    id: number | null;
    /**
     * The human-friendly name of the game.
     */
    name: string;
};
/**
 * An instance.
 */
export type Instance = {
    /**
     * The instance's ID in the database.
     */
    id: number | null;
    /**
     * The name of the instance.
     */
    name: string;
    /**
     * The game that this instance belongs to.
     */
    game_id: number;
    /**
     * The data folder for this instance.
     */
    data_dir: string;
    /**
     * The cache folder for this instance.
     * This will commonly be the same cache folder
     * for all instances that belong to this game.
     */
    cache_dir: string;
    /**
     * Where the game was installed.
     * This will commonly be the same folder for
     * all instances that belong to this game.
     */
    install_dir: string;
    /**
     * The user-set description of the instance.
     * This is blank by default.
     */
    description: string;
    /**
     * A UTC timestamp of when the instance was
     * created.
     */
    created: number;
    /**
     * A UTC timestamp of when the instance was
     * last updated/changed.
     */
    updated: number;
    /**
     * The JSON-serialized mod loader for this instance.
     */
    loader: string | null;
};
export type Mod = {
    /**
     * The mod's ID in its source.
     * This could be an integer or a string,
     * and since we support multiple platforms,
     * a string is the most flexible.
     */
    id: string;
    /**
     * The game ID.
     */
    game_id: number | null;
    /**
     * The mod's versions.
     */
    versions: ModVersion[];
    /**
     * The mod's name.
     */
    name: string;
    /**
     * Where the mod came from.
     * This is a reference to a source in the database.
     */
    source: number;
    /**
     * The mod's icon.
     */
    icon: string | null;
    /**
     * The mod's banner.
     */
    banner: string | null;
    /**
     * The mod's description.
     */
    desc: string | null;
    /**
     * The mod's author.
     */
    author: string | null;
    /**
     * The mod's downloads.
     */
    downloads: number;
    /**
     * The mod's followers.
     */
    followers: number;
    /**
     * The mod's web URL.
     */
    url: string | null;
};
/**
 * The ModLoader type.
 * Each element contains the Minecraft version
 * and then its version.
 */
export type ModLoader =
    | { Vanilla: string }
    | { Forge: [string, string] }
    | { NeoForge: [string, string] }
    | { Fabric: [string, string] }
    | { Quilt: [string, string] }
    /**
     * This is for any other game, I just didn't feel
     * like dealing with recursive dependencies.
     */
    | "None";
export type ModVersion = {
    /**
     * The version ID.
     */
    id: string;
    /**
     * The version name. Some sources may not have this.
     */
    name: string | null;
    /**
     * The file name.
     */
    file_name: string | null;
    /**
     * The size in bytes of the file.
     */
    size: string | null;
    /**
     * The SHA-512 hash of the file.
     */
    hash: string | null;
    /**
     * The download URL.
     */
    url: string | null;
};
export type PluginInfo = {
    id: string;
    game: number;
    display_name: string;
    icon_url: string;
    banner_url: string;
    fallback_dir: string | null;
    resolvers: SourceMapping[];
};
export type ProgressPayload = {
    /**
     * The total number of iterations. For a request or
     * file operation, this will be the total size of
     * the file, in bytes.
     */
    total: number;
    /**
     * The current processed iterations count. For a
     * request or file operation, this will be how many
     * bytes have been received/processed/written.
     */
    current: number;
    /**
     * The name of the file or operation being done.
     */
    name: string;
};
/**
 * A mod source.
 * This represents a mod provider, like Modrinth,
 * CurseForge, SpaceDock, etc.
 */
export type Source = {
    /**
     * The ID of this source in the database.
     */
    id: number | null;
    /**
     * The human-friendly name of this source.
     */
    name: string;
    /**
     * The source's API base URL.
     */
    base_url: string;
};
export type SourceMapping =
    | "SpaceDock"
    | "Ckan"
    | "Wormhole"
    | "Local"
    | "CurseForge"
    | "Modrinth"
    | "Thunderstore"
    | "Nexus"
    | "Unknown";
export type Sources =
    | "SpaceDock"
    | "Ckan"
    | "Wormhole"
    | "Local"
    | "CurseForge"
    | "Modrinth"
    | "Thunderstore"
    | "Nexus"
    | "Unknown";
export type SupportedSource = {
    id: number | null;
    is_supported: boolean;
    source_id: number;
    game_id: number;
};

/** tauri-specta globals **/

import { invoke as TAURI_INVOKE } from "@tauri-apps/api/tauri";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindowHandle as __WebviewWindowHandle__ } from "@tauri-apps/api/window";

type __EventObj__<T> = {
    listen: (cb: TAURI_API_EVENT.EventCallback<T>) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
    once: (cb: TAURI_API_EVENT.EventCallback<T>) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
    emit: T extends null
        ? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
        : (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type __Result__<T, E> = { status: "ok"; data: T } | { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(mappings: Record<keyof T, string>) {
    return new Proxy(
        {} as unknown as {
            [K in keyof T]: __EventObj__<T[K]> & {
                (handle: __WebviewWindowHandle__): __EventObj__<T[K]>;
            };
        },
        {
            get: (_, event) => {
                const name = mappings[event as keyof T];

                return new Proxy((() => {}) as any, {
                    apply: (_, __, [window]: [__WebviewWindowHandle__]) => ({
                        listen: (arg: any) => window.listen(name, arg),
                        once: (arg: any) => window.once(name, arg),
                        emit: (arg: any) => window.emit(name, arg),
                    }),
                    get: (_, command: keyof __EventObj__<any>) => {
                        switch (command) {
                            case "listen":
                                return (arg: any) => TAURI_API_EVENT.listen(name, arg);
                            case "once":
                                return (arg: any) => TAURI_API_EVENT.once(name, arg);
                            case "emit":
                                return (arg: any) => TAURI_API_EVENT.emit(name, arg);
                        }
                    },
                });
            },
        }
    );
}
